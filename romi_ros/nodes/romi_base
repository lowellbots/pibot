#!/usr/bin/env python

import math

import rospy
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
from std_msgs.msg import Float32

from romi_ros import Romi

def shutdown_hook():
    rospy.loginfo("Romi Base shutting down")

def callback(msg):
    rospy.loginfo("Received Twist:\n\r%s", msg)
    #do math, make motors spin

def integrateOdometry(linear, angular):
    if abs(angular) < 1e-6:


def main():
    nh = rospy.init_node('romi_base')
    rospy.on_shutdown(shutdown_hook)

    rate = rospy.Rate(20) #20Hz

    base_frame_id = rospy.get_param('base/frame_id', 'base_link')
    wheel_diameter = rospy.get_param('base/wheel_diameter', 0.07) #wheel_diameter in meters
    wheel_circumference = wheel_diameter * math.pi
    wheelbase = rospy.get_param('base/wheelbase', .141) #wheelbase in meters
    encoder_cpr = rospy.get_param('encoder/counts_per_rev', 12*120) #number of encoder counts *per wheel revolution*
    meters_per_count = wheel_circumference / encoder_cpr #distance a point on the diameter of the wheel would travel per encoder count
        
    # Encoder directions:
    # +1 means an increase in encoder tick represents the wheel rotating toward the front of the chassis
    left_encoder_direction = rospy.get_param('encoder/left/direction', 1)
    right_encoder_direction = rospy.get_param('encoder/right/direction', 1)

    cmd_vel_sub = rospy.Subscriber("cmd_vel", Twist, callback)
    odom_pub = rospy.Publisher("odom", Odometry, queue_size=1) 

    r = Romi()
    r.reset_encoders()
    r.beepBoop()

    t_old = rospy.Time.now()
    left_wheel_old_pos = 0
    right_wheel_old_pos = 0

    while not rospy.is_shutdown():
        #should probably also publish battery voltage here....

        # Grab a timestamp for the current loop iteration
        t = rospy.Time.now()

        # Calculate time since last loop iteration
        dt = t - t_old
        #rospy.loginfo("dt: %s", dt.to_sec())

        # Read the encoders, catch occasional I/O Errors
        try:
            encoders = r.read_encoders()
        except OSError:
            rospy.logwarn("Remote I/O error")

        # Convert encoder ticks to wheel distance travelled since startup
        left_wheel_cur_pos, right_wheel_cur_pos = [encoder*meters_per_count for encoder in encoders]
        #rospy.loginfo("Left: %s, Right: %s", left_wheel_cur_pos, right_wheel_cur_pos)

        # Estimate per wheel velocities
        left_wheel_est_vel = (left_wheel_cur_pos - left_wheel_old_pos)/dt.to_sec()
        right_wheel_est_vel = (right_wheel_cur_pos - right_wheel_old_pos)/dt.to_sec()
        #rospy.loginfo("Left Vel: %s, Right Vel: %s", left_wheel_est_vel, right_wheel_est_vel)

        # Estimate vehicle motion based on wheel velocities
        linear_vel = (right_wheel_est_vel + left_wheel_est_vel) *0.5
        angular_vel  = (right_wheel_est_vel - left_wheel_est_vel) / wheelbase

        rospy.loginfo("Linear Velocity: %s, Angular Velocity: %s", linear_vel, angular_vel)

        # Stuff into an odometry message and *shipit*
        odom_msg = Odometry()
        odom_msg.header.frame_id = base_frame_id
        odom_msg.header.stamp = rospy.Time.now()

        # Update the old timestamp and positions with current values
        t_old = t 
        left_wheel_old_pos = left_wheel_cur_pos
        right_wheel_old_pos = right_wheel_cur_pos

        # Sleep for a bit.
        rate.sleep()



if __name__ == '__main__':
    main()
