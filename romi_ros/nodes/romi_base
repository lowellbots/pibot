#!/usr/bin/env python

from math import pi, sin, cos

import rospy
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
from std_msgs.msg import Float32
from tf.transformations import quaternion_from_euler

from romi_ros import Romi

def shutdown_hook():
    rospy.loginfo("Romi Base shutting down")

def callback(msg):
    rospy.loginfo("Received Twist:\n\r%s", msg)
    #do math, make motors spin


def main():
    nh = rospy.init_node('romi_base')
    rospy.on_shutdown(shutdown_hook)

    rate = rospy.Rate(20) #20Hz

    base_frame_id = rospy.get_param('base/frame_id', 'base_link')
    wheel_diameter = rospy.get_param('base/wheel_diameter', 0.07) #wheel_diameter in meters
    wheel_circumference = wheel_diameter * pi
    wheelbase = rospy.get_param('base/wheelbase', .141) #wheelbase in meters
    encoder_cpr = rospy.get_param('encoder/counts_per_rev', 12.0*120.0) #number of encoder counts *per wheel revolution*
    meters_per_count = wheel_circumference / encoder_cpr #distance a point on the diameter of the wheel would travel per encoder count
        
    # Encoder directions:
    # +1 means an increase in encoder tick represents the wheel rotating toward the front of the chassis
    left_encoder_direction = rospy.get_param('encoder/left/direction', 1)
    right_encoder_direction = rospy.get_param('encoder/right/direction', 1)

    cmd_vel_sub = rospy.Subscriber("cmd_vel", Twist, callback)
    odom_pub = rospy.Publisher("odom", Odometry, queue_size=1) 

    romi = Romi()
    romi.reset_encoders()
    romi.beepBoop()

    t_old = None
    left_wheel_old_pos = 0
    right_wheel_old_pos = 0

    x = 0
    y = 0
    heading = 0

    while not rospy.is_shutdown():
        # Grab a timestamp for the current loop iteration
        t = rospy.Time.now()
        if t_old is not None:
            #should probably also publish battery voltage here....


            # Calculate time since last loop iteration
            dt = (t - t_old).to_sec()

            # Read the encoders, catch occasional I/O Errors
            # If we get an I/O error, we should abort this loop iteration
            try:
                encoders = romi.read_encoders()

                # Update the old encoder values with current values
                old_encoders = encoders
            except OSError:
                rospy.logwarn("Remote I/O error.")
                continue

            # Convert encoder ticks to wheel distance travelled since startup
            left_wheel_cur_pos, right_wheel_cur_pos = [encoder*meters_per_count for encoder in encoders]


            # Estimate per wheel velocities
            left_wheel_est_vel = (left_wheel_cur_pos - left_wheel_old_pos)/dt
            right_wheel_est_vel = (right_wheel_cur_pos - right_wheel_old_pos)/dt

            # Estimate vehicle motion based on wheel velocities
            linear_vel = (right_wheel_est_vel + left_wheel_est_vel) *0.5
            angular_vel  = (right_wheel_est_vel - left_wheel_est_vel) / wheelbase

            # K.I.S.S. Odometry integration.  Since our counter is quite fast, let's assume we haven't missed any counts
            # and it's safe to simply use addition.  No more Trailing Average Filter + Runge Kutta for you!
            heading += angular_vel*dt

            delta_x = linear_vel * cos(heading) * dt
            x += delta_x

            delta_y = linear_vel * sin(heading) * dt
            y += delta_y


            # Stuff into an odometry message and *shipit*
            odom_msg = Odometry()
            odom_msg.header.frame_id = base_frame_id
            odom_msg.header.stamp = rospy.Time.now()

            odom_msg.pose.pose.position.x = x
            odom_msg.pose.pose.position.y = y

            q = quaternion_from_euler(0, 0, heading)
            odom_msg.pose.pose.orientation.x = q[0]
            odom_msg.pose.pose.orientation.x = q[1]
            odom_msg.pose.pose.orientation.x = q[2]
            odom_msg.pose.pose.orientation.x = q[3]

            odom_msg.twist.twist.linear.x = linear_vel
            odom_msg.twist.twist.angular.z = angular_vel

            odom_pub.publish(odom_msg)

            # Update the old positions with current values
            left_wheel_old_pos = left_wheel_cur_pos
            right_wheel_old_pos = right_wheel_cur_pos

        # Update the old timestamp with the current time.
        t_old = t
        # Sleep for a bit.
        rate.sleep()



if __name__ == '__main__':
    main()
